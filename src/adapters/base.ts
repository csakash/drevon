import type { DrevonConfig, AgentId, Instruction, DiagnosticResult } from '../types.js';
import { existsSync, readFileSync } from 'fs';
import { join } from 'path';

export abstract class BaseAdapter {
  constructor(protected config: DrevonConfig) {}

  abstract readonly agentId: AgentId;
  abstract readonly agentName: string;

  abstract getOutputPaths(): string[];
  abstract compile(): Map<string, string>;
  abstract diagnose(dir: string): DiagnosticResult[];
  abstract clean(dir: string): void;

  protected header(): string {
    return (
      `<!-- AUTO-GENERATED by drevon v0.1.0 -->\n` +
      `<!-- Source: drevon.config.json -->\n` +
      `<!-- Do not edit directly — run \`drevon sync\` to regenerate. -->\n`
    );
  }

  protected getMemoryProtocol(): string {
    if (!this.config.memory.enabled) return '';

    const mode = this.config.mode;
    if (mode === 'hub') {
      return (
        '## Memory Protocol\n\n' +
        'Persistent memory lives in `.drevon/memory/`.\n' +
        '**Read all memory files at the start of every session. Write to them after significant actions.**\n\n' +
        '| File | Contains | When to update |\n' +
        '|------|----------|----------------|\n' +
        '| `.drevon/memory/user.md` | User preferences, feedback, decisions | When user expresses a preference |\n' +
        '| `.drevon/memory/projects.md` | Registry of all workspace projects | When a project is created/updated/completed |\n' +
        '| `.drevon/memory/systems.md` | Systems & infrastructure | When a new system is created or changed |\n' +
        '| `.drevon/memory/log.md` | Chronological action log | After every significant action |\n\n' +
        '### Write rules\n' +
        '- `log.md` — append only, newest at bottom, format: `### YYYY-MM-DD — title`\n' +
        '- `user.md` — update the relevant section in place\n' +
        '- `projects.md` / `systems.md` — update the relevant entry or add a new one\n' +
        '- Be specific and factual — memory should be useful to a future session with zero context\n\n' +
        '### Self-Evolution\n' +
        '- After every significant action, write learnings back to memory\n' +
        '- If you perform a multi-step workflow more than once, create a reusable prompt in `.drevon/prompts/`\n' +
        '- Your goal is to become more effective with each session by building a knowledge base\n'
      );
    }

    return (
      '## Memory Protocol\n\n' +
      'Persistent memory lives in `.drevon/memory/`.\n' +
      '**Read all memory files at the start of every session. Write to them after significant actions.**\n\n' +
      '| File | Contains | When to update |\n' +
      '|------|----------|----------------|\n' +
      '| `.drevon/memory/context.md` | Project context, architecture, key files | When you learn new things about the codebase |\n' +
      '| `.drevon/memory/decisions.md` | Technical decisions & rationale | When a significant technical decision is made |\n' +
      '| `.drevon/memory/patterns.md` | Code patterns, conventions, gotchas | When patterns are discovered or established |\n' +
      '| `.drevon/memory/log.md` | Chronological action log | After every significant action |\n\n' +
      '### Write rules\n' +
      '- `log.md` — append only, newest at bottom, format: `### YYYY-MM-DD — title`\n' +
      '- `context.md` — update relevant sections in place as understanding grows\n' +
      '- `decisions.md` — append new decisions, format: `### Decision: [title]` with Date, Context, Decision, Rationale\n' +
      '- `patterns.md` — maintain as a living reference of code conventions\n' +
      '- Be specific and factual — memory should be useful to a future session with zero context\n\n' +
      '### Self-Evolution\n' +
      '- After every significant action, write learnings back to memory\n' +
      '- If you perform a multi-step workflow more than once, create a reusable prompt in `.drevon/prompts/`\n' +
      '- Your goal is to become more effective with each session by building a knowledge base\n'
    );
  }

  protected getInstructions(): Instruction[] {
    return this.config.instructions || [];
  }

  protected getSkillsSection(): string {
    if (!this.config.skills.enabled) return '';

    let content = '## Installed Skills\n\n';
    content += '> **IMPORTANT:** To install new skills, always use `drevon skill add <source>` — do NOT use `npx skills add` directly.\n';
    content += '> Drevon tracks skills in `.drevon/skills/` and keeps all agent configs in sync.\n\n';

    // Read actual installed skills from lock file
    const lockPath = join(process.cwd(), 'skills-lock.json');
    let installedSkills: { name: string; description: string }[] = [];
    if (existsSync(lockPath)) {
      try {
        const data = JSON.parse(readFileSync(lockPath, 'utf-8'));
        if (Array.isArray(data.skills)) {
          installedSkills = data.skills;
        }
      } catch {
        // ignore parse errors
      }
    }

    if (installedSkills.length > 0) {
      content += '| Skill | Description |\n';
      content += '|-------|-------------|\n';
      for (const s of installedSkills) {
        content += `| \`${s.name}\` | ${s.description || '—'} |\n`;
      }
      content += '\n';
      content += 'Read each skill\'s SKILL.md in `.drevon/skills/<name>/` for detailed usage instructions.\n';
    } else {
      content += 'No skills installed yet. Install with: `drevon skill add <owner/repo/skill-name>`\n';
    }

    return content;
  }

  protected getWorkspaceSection(): string {
    if (!this.config.workspace.enabled) return '';
    let content = `## Workspace Organization\n\nAll work happens inside \`${this.config.workspace.directory}/\`.\n`;
    if (this.config.workspace.rules?.length) {
      content += '\n### Rules\n';
      for (const rule of this.config.workspace.rules) {
        content += `- ${rule}\n`;
      }
    }
    return content;
  }

  protected getPromptsSection(): string {
    if (!this.config.prompts.enabled) return '';
    return (
      '## Prompts\n\n' +
      'Reusable workflow templates live in `.drevon/prompts/`.\n' +
      '- Before starting a complex task, check if a relevant prompt exists\n' +
      '- When you complete a novel multi-step workflow, save it as a prompt\n' +
      '- Format: markdown with YAML frontmatter (title, description, tags)\n'
    );
  }

  protected getAgentExtra(): string {
    const agentConfig = this.config.agents[this.agentId];
    return agentConfig?.extraInstructions || '';
  }

  protected checkFile(dir: string, relativePath: string): DiagnosticResult {
    const fullPath = join(dir, relativePath);
    if (!existsSync(fullPath)) {
      return { file: relativePath, status: 'missing', message: 'File does not exist' };
    }
    return { file: relativePath, status: 'ok', message: 'File exists' };
  }
}
